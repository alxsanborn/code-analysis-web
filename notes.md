##Stateless components

Before doing this exercise, I had read in a few blogs that stateless React components are desirable because they cut down on the WET code you might be writing, it makes it easier for programmers unfamiliar with React to read your code, and it cuts down on a lot of the confusion with "this" and what "this" refers to at specific points in the code, among other reasons. As I looked at the code, I did notice there seemed to be a lot of code smells with the event listeners. I decided this was going to be the first thing I was going to work on because it was likely to be the most major change, and I figured that once I got the main functionality working, I could rebuild the features around the main stateless App component.
- I wanted to first make sure that in the stateless component, I would be able to retrieve the json data as props in some sort of form that I would be able to manipulate and render on the page.
- From my reading on stateless components, I tried to identify some marked features: no state, no constructor or super, whatever props you have are passed through as a main variable, no render, no "this" or "bind", and components are functions, not classes.  
- I ultimately decided I didn't need a promise for a stateless React app. In the original code, I noticed that one of the benefits was that it allowed the DOM's initial state to load without the list of the people, and then once the DOM loaded, the code resolved the promise and returned the values. In my stateless component, I just wanted the data to render on initialize, so I deleted it.
- The reason why I have one larger commit message/less commit messages for each step was because I think it's important to only push code that produces some sort of functionality with a given change/set of changes, so as to not confuse the people you're working with, and that was more difficult to do with this particular task I was doing.

##Rebuilding the table
- I decided that for now, I would just copy and paste all of the functions that you identified as contributing to VIEWS within the main App component. These functions (listContainer, listRow, Thumbnail) belong in the App component because they directly take information rendered from the props variable and map it on to the Reactified HTML. In React, you can only render one React component directly onto the DOM (in this case App) and all of your other HTML elements must be organized as children of this parent in some manner. In order to just do this, I only needed to make sure that personList (line 271) was taking in the props array rendered from the json data (a bit more on this later).

##Features

###Sorting by first and last names
- I noticed that not only was the last name sort function not working correctly but that the logic seemed a little confusing. The functions were sorting the list of people via the present keys listed within the array of objects (name and url). The first name function was working because it was using the "name" key to sort, but that's more of a false positive and doesn't allow the function to access the last name without some contorted logic. On that note, the last name sort function wasn't working because the logic was completely wrong - it only was producing a reversed order of the first name sort. I decided that I would solve this by using the getFirstName and getLastName functions to parse through the names as I was getting them from the API and just push them into the array I would be using so that I would have individual first and last names available to me. I would then be able to sort by "first" and "last" keys, which are more representative of the process, rather than use some contorted logic to parse out last name in the last name sort. I also changed the formatting of the getLastName function to ES6 just to make it look consistent and neat with the getFirstName function.

 - I also had problems with getting the sorted lists to re-render on the page - since I deleted state, I didn't have that setState feature listening for change and re-rendering when the state changed. I did some research on Google and found on a React forum (monitored by the Facebook React team) that the recommended way was to just write ReactDOM.render and then re-render my main component. So I did that, but was frustrated that it still seemed to not be working. I did some more research and some people suggested that the problem was that a different "key" attribute needed to be rendered each time you want to re-render the page, so I tried that and not only did it not work, but I noticed from inspecting the elements (data-reactid) that React was producing a different version number each time I was re-rendering (.0 -> .1) and yet nothing changed. That's when I realized that I was making a silly mistake - the array I was passing through was the original array from the API request (visiblePersonList), rather than the dynamic props argument (props) being passed through the App component. I changed that and it worked finally.

###Shuffle
- I realized that the array was being copied incorrectly; the array was leaving out the person at index 0 in the array (in this case, Abby Cook) before shuffling. I fixed it by writing code that didn't slice. I made sure to copy the array as a new array because I wanted to make sure I was following the directions ("make a copy and don't mutate the passed in list"). Another small problem I was having was that the DOM kept shuffling the data on initial load, even though I hadn't clicked anything. I solved this by adding another function that passed the event through as a variable.

###Search
- The main problem with this seemed to be that the searches were case sensitive, which isn't really user friendly, and it required a user to type in the full name of the person to get a result, which also isn't user friendly. I changed the method to not be case sensitive and to allow for substring matches, rather than entire string matches.
- At this point, the search function seemed to be redundant and caused me more problems. I had two onChange event listeners and when the page re-rendered, it deleted whatever previous input the user entered, which isn't helpful. I didn't think it was necessary to make "Search" its own unique element since it is an input anyways, so I edited/combined the code for that input element, and that seemed to make the search function work. 
